use crate::layout::recursive::{
    global_values::InteractionElements, NUM_COLUMNS_FIRST, NUM_COLUMNS_SECOND,
};
use cairovm_verifier_commitment::vector;
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use starknet_core::serde::unsigned_field_element::UfeHex;
use starknet_crypto::Felt;

const MAX_N_COLUMNS: Felt = Felt::from_hex_unchecked("0x80");

// Commitment values for the Traces component. Used to generate a commitment by "reading" these
// values from the channel.
#[serde_as]
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct UnsentCommitment {
    #[serde_as(as = "UfeHex")]
    pub original: Felt,
    #[serde_as(as = "UfeHex")]
    pub interaction: Felt,
}

// Commitment for the Traces component.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Commitment {
    // Commitment to the first trace.
    pub original: cairovm_verifier_commitment::table::types::Commitment,
    // The interaction elements that were sent to the prover after the first trace commitment (e.g.
    // memory interaction).
    pub interaction_elements: InteractionElements,
    // Commitment to the second (interaction) trace.
    pub interaction: cairovm_verifier_commitment::table::types::Commitment,
}

// Responses for queries to the AIR commitment.
// The queries are usually generated by the next component down the line (e.g. FRI).
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Decommitment {
    // Responses for queries to the original trace.
    original: cairovm_verifier_commitment::table::types::Decommitment,
    // Responses for queries to the interaction trace.
    interaction: cairovm_verifier_commitment::table::types::Decommitment,
}

// A witness for a decommitment of the AIR traces over queries.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Witness {
    original: cairovm_verifier_commitment::table::types::Witness,
    interaction: cairovm_verifier_commitment::table::types::Witness,
}

// Configuration for the Traces component.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Config {
    pub original: cairovm_verifier_commitment::table::config::Config,
    pub interaction: cairovm_verifier_commitment::table::config::Config,
}

impl Config {
    pub fn validate(
        &self,
        log_eval_domain_size: Felt,
        n_verifier_friendly_commitment_layers: Felt,
    ) -> Result<(), Error> {
        if self.original.n_columns < Felt::ONE || self.original.n_columns > MAX_N_COLUMNS {
            return Err(Error::OutOfBounds { min: Felt::ONE, max: MAX_N_COLUMNS });
        }
        if self.interaction.n_columns < Felt::ONE || self.interaction.n_columns > MAX_N_COLUMNS {
            return Err(Error::OutOfBounds { min: Felt::ONE, max: MAX_N_COLUMNS });
        }

        if self.original.n_columns != NUM_COLUMNS_FIRST.into() {
            return Err(Error::ColumnsNumInvalid);
        }

        if self.interaction.n_columns != NUM_COLUMNS_SECOND.into() {
            return Err(Error::ColumnsNumInvalid);
        }

        Ok(self
            .original
            .vector
            .validate(log_eval_domain_size, n_verifier_friendly_commitment_layers)
            .and(
                self.interaction
                    .vector
                    .validate(log_eval_domain_size, n_verifier_friendly_commitment_layers),
            )?)
    }
}

use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("value out of bounds {min} - {max}")]
    OutOfBounds { min: Felt, max: Felt },

    #[error("wrong numbers of columns")]
    ColumnsNumInvalid,

    #[error("Vector Error")]
    Vector(#[from] vector::config::Error),
}
